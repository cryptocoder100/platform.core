#pragma warning disable SA1600
#pragma warning disable CA1062
#pragma warning disable CA1506
namespace Exos.MinimalPlatformService
{
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using Exos.MinimalPlatformService.Models;
    using Exos.Platform.AspNetCore.Extensions;
    using Exos.Platform.AspNetCore.Helpers;
    using Exos.Platform.AspNetCore.KeyVault;
    using Exos.Platform.AspNetCore.Middleware;
    using Exos.Platform.AspNetCore.Resiliency.Policies;
    using Exos.Platform.AspNetCore.Security;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Hosting;
    using Polly;
    using Polly.Registry;

    public class Startup
    {
        public Startup(IConfiguration configuration, IWebHostEnvironment environment)
        {
            Configuration = configuration;
            Environment = environment;
        }

        public IConfiguration Configuration { get; }

        public IWebHostEnvironment Environment { get; }

        public static void Configure(IApplicationBuilder app)
        {
            // Enable CORS (see explanation above)
            app.UseCors(builder =>
            {
                builder
                    .AllowAnyOrigin()
                    .AllowAnyHeader()
                    .AllowAnyMethod();
            });

            // Enable our error handler middleware. We want this as early in the pipeline
            // as possible to catch any unhandled exceptions downstream.
            app.UseErrorHandler();

            // Automatically add a Tracking-Id header if not already present in the request
            // and make it available for downstream HttpClient calls.
            app.UseTrackingId();

            // The user context middleware will make use of the configuration options set above
            // and process the Authorization request header with the assumption that it is a
            // user context token generated by the gateway.
            app.UseUserContext();

            // Enable swagger and its UI
            app.UseSwagger();
            app.UseSwaggerUI(options =>
            {
                // Name the endpoint appropriately and use a relative path from your service root
                options.SwaggerEndpoint("v1/swagger.json", "TODO: API Title");
            });

            // Enable routes/controllers
            // app.UseMvc();
            app.UseRouting();

            app.UseAppMetrics();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });

            // Add Resilient Policies
            app.AddResilientPolicies(new Dictionary<string, IResilientPolicy>
            {
                { PolicyRegistryKeys.Http, app.ApplicationServices.GetService<IHttpRequestResiliencyPolicy>() },
            });

            // Throw a NotFoundException for and requests that are not handled by the middleware above
            app.RunNotFoundException();
        }

        public void ConfigureServices(IServiceCollection services)
        {
            // Add MVC services
            services.AddMvc();

            // Not strictly necessary for services which sit behind a gateway as our do,
            // however, it can make it a lot easier for local development/testing.
            services.AddCors();

            // If you want to use Redis and IDistributedCache DI interface
            services.AddStackExchangeRedisCache(options =>
            {
                options.Configuration = Configuration.GetConnectionString("DistributedRedisCache");
            });

            // Applies the standard configuration for JSON serialization and configures all
            // controller actions to require authentication. Use the AllowAnonymous attribute on
            // controllers or actions you want anonymous access to. For more control over platform
            // defaults, see the code in the ServiceCollectionExtensions.AddPlatformDefaults method.
            services.AddExosPlatformDefaults(Configuration, Environment);

            // Register the configuration options for handling user context tokens
            services.Configure<UserContextOptions>(Configuration.GetSection("UserContext"));

            // Register HttpClient as DI injectable using our custom factory that automatically
            // handles user context and tracking id propagation.
            // HTTP Client Configuration
            services.Configure<HttpRequestPolicyOptions>(Configuration.GetSection("ResiliencyPolicy:HttpRequestPolicyOptions"));
            services.AddSingleton<IHttpRequestResiliencyPolicy, HttpRequestResiliencyPolicy>();

            var platformDefaults = new PlatformDefaultsOptions();
            Configuration.GetSection("PlatformDefaults").Bind(platformDefaults);

            // HTTP Client with Authentication Header and Tracking Id
            services.AddHttpClient("Client_Authentication_Header_and_Tracking Id")
                .ConfigurePrimaryHttpMessageHandler(configure => new DefaultHttpClientHandler(platformDefaults))
                .EnrichWithTrackingId()
                .EnrichWithUserContext()
                .SetHandlerLifetime(TimeSpan.FromMinutes(
                    Configuration.GetValue<int>("ResiliencyPolicy:HttpRequestPolicyOptions:HandlerLifetimeInMinutes")))
                .AddPolicyHandler((sp, request) => sp.GetService<IReadOnlyPolicyRegistry<string>>().Get<IAsyncPolicy<HttpResponseMessage>>(PolicyRegistryKeys.Http));

            // HTTP Client with No Headers
            services.AddHttpClient("Client_No_Header")
                .ConfigurePrimaryHttpMessageHandler(configure => new DefaultHttpClientHandler(platformDefaults))
                .EnrichWithTrackingId()
                .SetHandlerLifetime(TimeSpan.FromMinutes(Configuration.GetValue<int>("ResiliencyPolicy:HttpRequestPolicyOptions:HandlerLifetimeInMinutes")))
                .AddPolicyHandler((sp, request) => sp.GetService<IReadOnlyPolicyRegistry<string>>().Get<IAsyncPolicy<HttpResponseMessage>>(PolicyRegistryKeys.Http));

            services.Configure<AzureKeyVaultSettings>(Configuration.GetSection("AzureKeyVault"));
            services.AddSingleton<AzureKeyVaultKeyClient>();

            // Generate a Swagger documentation file
            services.AddSwagger($"{AssemblyHelper.EntryAssemblyName}.xml");

            // Add status model singleton for the services to use
            services.AddSingleton<StatusModel>();

            // Add the background services
            services.AddSingleton<IHostedService, BackgroundPollingService>();
            services.AddSingleton<IHostedService, BackgroundSubscriptionService>();
        }
    }
}
#pragma warning restore SA1600
#pragma warning restore CA1062
#pragma warning restore CA1506